åœ¨haè£¡çš„å¯¦é«”id å¸Œæœ›æ˜¯
sensor.slave{slave_id}_jkbms

"""
ğŸ“Œ Switch Module ä»¥ä¸‹ç‚º module_switch.py
æ§åˆ¶ Modbus Coilï¼Œé€é Home Assistant MQTT Discovery è‡ªå‹•è¨»å†Šä¸¦èˆ‡ HA åŒæ­¥ç‹€æ…‹
"""

import time
import json
import modbus_mqtt_client

# ========================
# ğŸŸ¡ å¸¸æ•¸å®šç¾©
# ========================
COIL_START_ADDRESS = 0          # Modbus Coil èµ·å§‹ä½å€
COIL_COUNT = 8                  # Coil æ•¸é‡ï¼ˆé€šå¸¸ç‚º 8 æˆ–è‡ªå®šç¾©ï¼‰

COMPONENT = "switch"            # HA å…ƒä»¶é¡å‹ï¼ˆswitchï¼‰
NODE_ID = "hy01"                # è£ç½®ç¯€é» IDï¼ˆHA ç”¨ä¾†è­˜åˆ¥è¨­å‚™ï¼Œä¾‹å¦‚ hy01ï¼‰

# ========================
# ğŸŸ  ç™¼ä½ˆ Home Assistant Discovery è¨­å®š
# ========================
def publish_discovery_config(mqtt_client, slave_id):
    """
    ç™¼ä½ˆæ¯å€‹ coil çš„ HA Discovery è¨­å®šï¼ŒåŒ…å« slave_id æ–¼ topic/object_id
    Publish Home Assistant Discovery config for each coil
    """
    for index in range(COIL_COUNT):
        object_id = f"{NODE_ID}_slave{slave_id}_coil{index}"  # å¯¦é«” ID
        topic = f"homeassistant/{COMPONENT}/{object_id}/config"  # Discovery è¨­å®šä¸»é¡Œ

        config_payload = {
            "name": f"{object_id}",  # é¡¯ç¤ºåç¨±ï¼ˆå¯è®€ï¼‰
            "command_topic": f"{NODE_ID}/coil/{slave_id}/{index}/set",  # HA ç™¼é€æ§åˆ¶è¨Šæ¯çš„ä¸»é¡Œ
            "state_topic": f"{NODE_ID}/coil/{slave_id}/{index}/state",  # HA è®€å–ç‹€æ…‹çš„ä¸»é¡Œ
            "payload_on": "ON",         # é–‹çš„ payload
            "payload_off": "OFF",       # é—œçš„ payload
            "unique_id": object_id,     # HA å”¯ä¸€ ID
            "object_id": object_id,     # HA Entity ID ä¸­çš„ object_id éƒ¨åˆ†
            "device": {
                "identifiers": [f"{NODE_ID}_slave{slave_id}"],      # HA è£ç½®è­˜åˆ¥ç¢¼
                "name": f"{NODE_ID}_slave{slave_id}",               # é¡¯ç¤ºè£ç½®åç¨±
                "model": "Modbus Coil Controller",                  # å‹è™Ÿ
                "manufacturer": "YourCompany"                       # è£½é€ å•†
            }
        }

        mqtt_client.publish(topic, json.dumps(config_payload), retain=True)
        print(f"ğŸ“¢ ç™¼ä½ˆ HA è¨­å®šï¼š{topic}")
##çœç•¥éé‡é»		

# ä»¥ä¸‹ç‚º main.py 
"""
ğŸ“Œ ä¸»ç¨‹å¼
çµ±ä¸€å•Ÿå‹•æ‰€éœ€çš„æ¨¡çµ„ï¼ˆswitch, temp, ...ï¼‰
ä¸¦çµ±ä¸€ç®¡ç† Modbus Slave ID åŠ ModbusManager
"""
from pymodbus.server.async_io import StartTcpServer
from pymodbus.datastore import ModbusServerContext
import importlib
import threading
import modbus_mqtt_client
import module_switch
import module_temp
import module_waterlevel
# æ–°å¢é€™è¡Œä¾†å°å…¥ modbus_read_coils
import modbus_read_coils
# module_03 8dodi ç›£è¦–ä¹¾æ¥é»è¼ªå·¡æ¯5ç§’ä¸€æ¬¡ä¿®æ”¹åœ¨module_03.py time.sleep(5)
import module_03

def main():
    # ========================
    # ğŸŸ¡ æ¨¡çµ„å•Ÿç”¨/åœç”¨èˆ‡ç«™è™Ÿè¨­å®š
    # ========================
    modules = {
      "switch": {"enable": True, "slave_id": 3},
      "03": {"enable": False, "slave_id": 3},
      "temp": {"enable": False, "slave_id": 1},
      "waterlevel": {"enable": False, "slave_id": 5},
      "analog_input": {"enable": False, "slave_id": 1}
    }

    # ========================
    # ğŸ”µ é¦–æ¬¡å•Ÿå‹•åŸ·è¡Œä¸€æ¬¡ modbus_read_coils
    # ========================
    print("âœ… é¦–æ¬¡åŸ·è¡Œ modbus_read_coils.py")
    coil_status = modbus_read_coils.read_coils()
    if coil_status:
        modbus_read_coils.publish_coil_status(coil_status)
        print("âœ… é¦–æ¬¡åŒæ­¥ç‹€æ…‹å®Œæˆï¼Œå·²ä¸Šå ±MQTTï¼")
    else:
        print("âš ï¸ é¦–æ¬¡è®€å–ç·šåœˆå¤±æ•—ï¼Œæœªç™¼ä½ˆMQTT")

    # ========================
    # ğŸŸ  å»ºç«‹åŸ·è¡Œç·’ä¸¦å•Ÿå‹•æ¨¡çµ„
    # ========================
    threads = []


    if modules["switch"]["enable"]:
        t = threading.Thread(
            target=module_switch.run,
            args=(modules["switch"]["slave_id"], modbus_mqtt_client.modbus_manager),
            name="SwitchModule"
        )
        threads.append(t)

# çœç•¥éé‡é»module...

    # ========================
    # ğŸ”µ å•Ÿå‹•æ‰€æœ‰æ¨¡çµ„
    # ========================
    for t in threads:
        t.start()

    # ========================
    # ğŸ”´ ç­‰å¾…æ‰€æœ‰æ¨¡çµ„çµæŸï¼ˆé€šå¸¸å¸¸é§åŸ·è¡Œï¼‰
    # ========================
    for t in threads:
        t.join()

if __name__ == "__main__":
    main()

#####################åˆ†æ ¼ç·š###########

# ä»¥ä¸‹ç‚º modbus_mqtt_client.py

"""
ğŸ“Œ Modbus èˆ‡ MQTT é€£ç·šç®¡ç†æ¨¡çµ„
çµ±ä¸€ç®¡ç†é€£ç·šè³‡è¨Šã€å»ºç«‹é€£ç·šç‰©ä»¶ã€é¿å…é‡è¤‡é€£ç·š
åŒæ™‚æä¾›è‡ªå‹•é‡é€£çš„åŠŸèƒ½
"""

from pymodbus.client import ModbusTcpClient
import paho.mqtt.client as mqtt
import threading
import time

# ==============================
# ğŸŸ¡ Modbus åƒæ•¸ï¼ˆçµ±ä¸€ç®¡ç†ï¼‰
# ==============================
MODBUS_HOST = '192.168.88.190'
MODBUS_PORT = 502

# ==============================
# ğŸŸ  MQTT åƒæ•¸ï¼ˆçµ±ä¸€ç®¡ç†ï¼‰
# ==============================
MQTT_BROKER = '192.168.88.106'
MQTT_PORT = 1883
MQTT_USERNAME = 'mqtt'
MQTT_PASSWORD = 'mqtt'

# ==============================
# ğŸ”µ Modbus é€£ç·šç®¡ç†é¡åˆ¥ï¼ˆå–®ä¾‹ï¼‰
# ==============================
class ModbusManager:
    """
    ç”¨ä¾†ç®¡ç†å–®ä¸€å€‹ Modbus TCP é€£ç·šï¼ˆä¿æŒé€£ç·š & è‡ªå‹•é‡é€£ï¼‰
    """
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.lock = threading.Lock()
        self.client = ModbusTcpClient(host=self.host, port=self.port)
        self._connect()

    def _connect(self):
        """
        å˜—è©¦é€£æ¥ Modbus ä¼ºæœå™¨
        """
        if not self.client.is_socket_open():
            if self.client.connect():
                print(f"âœ… Modbus å·²é€£ç·š: {self.host}:{self.port}")
            else:
                print(f"âš ï¸ Modbus é€£ç·šå¤±æ•—: {self.host}:{self.port}")

    def get_client(self):
        """
        æä¾› Modbus client å¯¦ä¾‹ï¼ˆä¿æŒé€£ç·šï¼‰
        """
        with self.lock:
            if not self.client.is_socket_open():
                print("âš ï¸ Modbus é€£ç·šä¸­æ–·ï¼Œè‡ªå‹•é‡æ–°é€£ç·š...")
                self.client.close()
                self.client.connect()
            return self.client

    def close(self):
        """
        çµæŸé€£ç·š
        """
        with self.lock:
            self.client.close()

# ==============================
# ğŸŸ£ MQTT å®¢æˆ¶ç«¯ï¼ˆå…±ç”¨ï¼‰
# ==============================
def get_mqtt_client():
    """
    å»ºç«‹ MQTT å®¢æˆ¶ç«¯ï¼ˆå…±ç”¨è¨­å®šï¼‰
    """
    client = mqtt.Client(protocol=mqtt.MQTTv311)
    client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
    return client

# ==============================
# ğŸŸ¤ å–®ä¾‹ç®¡ç†å™¨ï¼ˆå¤–éƒ¨ä½¿ç”¨ï¼‰
# ==============================
modbus_manager = ModbusManager(MODBUS_HOST, MODBUS_PORT)

#####################åˆ†æ ¼ç·š###########